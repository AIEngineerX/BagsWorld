/**
 * Wallet Authentication Utilities
 *
 * Provides cryptographic verification of wallet ownership using
 * Solana message signing. Used for admin authentication and
 * other privileged operations.
 *
 * Uses stateless challenge verification for serverless compatibility.
 *
 * SECURITY: CHALLENGE_SECRET and SESSION_SECRET must be set in production.
 * Generate with: openssl rand -base64 32
 */

import { PublicKey } from "@solana/web3.js";
import nacl from "tweetnacl";
import bs58 from "bs58";
import crypto from "crypto";
import { getRequiredSecret, validateSecretStrength, isProduction } from "./env-utils";

// Challenge message prefix - prevents signature reuse across apps
const MESSAGE_PREFIX = "BagsWorld Auth";

// Challenge expiry time (5 minutes)
const CHALLENGE_EXPIRY_MS = 5 * 60 * 1000;

// Secret for HMAC - REQUIRED in production, dev fallback for local testing
const CHALLENGE_SECRET = getRequiredSecret(
  "CHALLENGE_SECRET",
  "bagsworld-local-dev-secret-do-not-use-in-production"
);

// Validate secret strength in production
validateSecretStrength("CHALLENGE_SECRET", CHALLENGE_SECRET);

/**
 * Generate HMAC for challenge validation (stateless verification)
 */
function generateChallengeHmac(wallet: string, timestamp: number, nonce: string): string {
  const data = `${wallet}:${timestamp}:${nonce}`;
  return crypto.createHmac("sha256", CHALLENGE_SECRET).update(data).digest("hex").slice(0, 16);
}

/**
 * Generate a unique challenge for a wallet to sign
 * Challenge format includes HMAC for stateless verification
 */
export function generateChallenge(walletAddress: string): string {
  const timestamp = Date.now();
  const nonce = Math.random().toString(36).substring(2, 15);
  const hmac = generateChallengeHmac(walletAddress, timestamp, nonce);

  // Include all data needed for stateless verification in the challenge itself
  const challenge = `${MESSAGE_PREFIX}\nWallet: ${walletAddress}\nTimestamp: ${timestamp}\nNonce: ${nonce}\nHmac: ${hmac}`;

  return challenge;
}

/**
 * Parse challenge to extract components
 */
function parseChallenge(message: string): {
  wallet: string;
  timestamp: number;
  nonce: string;
  hmac: string;
} | null {
  try {
    const walletMatch = message.match(/Wallet: ([A-Za-z0-9]+)/);
    const timestampMatch = message.match(/Timestamp: (\d+)/);
    const nonceMatch = message.match(/Nonce: ([a-z0-9]+)/);
    const hmacMatch = message.match(/Hmac: ([a-f0-9]+)/);

    if (!walletMatch || !timestampMatch || !nonceMatch || !hmacMatch) {
      return null;
    }

    return {
      wallet: walletMatch[1],
      timestamp: parseInt(timestampMatch[1], 10),
      nonce: nonceMatch[1],
      hmac: hmacMatch[1],
    };
  } catch {
    return null;
  }
}

/**
 * Verify a signed challenge from a wallet (stateless - works in serverless)
 */
export function verifySignature(
  walletAddress: string,
  signature: string,
  message: string
): boolean {
  try {
    // Parse the challenge to get embedded data
    const parsed = parseChallenge(message);

    if (!parsed) {
      console.warn("[WalletAuth] Failed to parse challenge message");
      return false;
    }

    // Verify wallet matches
    if (parsed.wallet !== walletAddress) {
      console.warn("[WalletAuth] Wallet mismatch in challenge");
      return false;
    }

    // Verify not expired
    if (Date.now() > parsed.timestamp + CHALLENGE_EXPIRY_MS) {
      console.warn("[WalletAuth] Challenge expired");
      return false;
    }

    // Verify HMAC (proves challenge was generated by our server)
    const expectedHmac = generateChallengeHmac(parsed.wallet, parsed.timestamp, parsed.nonce);
    if (parsed.hmac !== expectedHmac) {
      console.warn("[WalletAuth] Invalid challenge HMAC");
      return false;
    }

    // Decode the signature and public key
    const signatureBytes = bs58.decode(signature);
    const publicKeyBytes = new PublicKey(walletAddress).toBytes();
    const messageBytes = new TextEncoder().encode(message);

    // Verify the signature using nacl
    const isValid = nacl.sign.detached.verify(messageBytes, signatureBytes, publicKeyBytes);

    return isValid;
  } catch (error) {
    console.error("[WalletAuth] Signature verification error:", error);
    return false;
  }
}

/**
 * Verify admin access with signature
 */
export function verifyAdminSignature(
  walletAddress: string,
  signature: string,
  message: string,
  adminWallet: string | undefined
): { valid: boolean; error?: string } {
  // Check if wallet is the admin wallet
  if (!adminWallet) {
    return { valid: false, error: "Admin wallet not configured" };
  }

  if (walletAddress !== adminWallet) {
    return { valid: false, error: "Wallet is not an admin" };
  }

  // Verify the signature
  if (!verifySignature(walletAddress, signature, message)) {
    return { valid: false, error: "Invalid signature" };
  }

  return { valid: true };
}

/**
 * Session token management for authenticated admins
 * Uses stateless HMAC-based tokens for serverless compatibility
 */

// Session duration (1 hour)
const SESSION_DURATION_MS = 60 * 60 * 1000;

// Secret for session HMAC - uses separate secret if provided, falls back to challenge secret
// Both must meet minimum strength requirements in production
const SESSION_SECRET = process.env.SESSION_SECRET || CHALLENGE_SECRET;

// Validate session secret strength in production (if using separate secret)
if (process.env.SESSION_SECRET) {
  validateSecretStrength("SESSION_SECRET", SESSION_SECRET);
}

/**
 * Create a stateless session token after successful signature verification
 * Token format: wallet:expires:hmac (base58 encoded)
 */
export function createSessionToken(walletAddress: string): string {
  const expires = Date.now() + SESSION_DURATION_MS;
  const data = `${walletAddress}:${expires}`;
  const hmac = crypto.createHmac("sha256", SESSION_SECRET).update(data).digest("hex").slice(0, 16);

  // Encode as base58 for URL safety
  const tokenData = `${walletAddress}:${expires}:${hmac}`;
  return bs58.encode(Buffer.from(tokenData));
}

/**
 * Verify a stateless session token and return the wallet address
 */
export function verifySessionToken(token: string): string | null {
  try {
    // Decode the token
    const decoded = Buffer.from(bs58.decode(token)).toString();
    const parts = decoded.split(":");

    if (parts.length !== 3) {
      return null;
    }

    const [wallet, expiresStr, hmac] = parts;
    const expires = parseInt(expiresStr, 10);

    // Check expiry
    if (Date.now() > expires) {
      return null;
    }

    // Verify HMAC
    const expectedHmac = crypto
      .createHmac("sha256", SESSION_SECRET)
      .update(`${wallet}:${expires}`)
      .digest("hex")
      .slice(0, 16);

    if (hmac !== expectedHmac) {
      return null;
    }

    return wallet;
  } catch {
    return null;
  }
}

/**
 * Invalidate a session token (no-op for stateless tokens, kept for API compatibility)
 */
export function invalidateSession(_token: string): void {
  // Stateless tokens can't be invalidated server-side
  // Client should delete the token from storage
}
